# Chapter 1. 자바 8,9,10,11 : 무슨 일이 일어나고 있는가?

### 왜 아직도 자바는 변화하는가? <br>
- 새로운 언어가 등장하기 때문에 진화하지 않은 기존 언어는 활용X. (like 생태계)<br>

> [초반] <br>
  > - 많은 라이브러리와 스레드와 락을 이용한 동시성 일부 지원. <br>
  > - 코드를 JVM 바이트 코드로 컴파일하기 때문에 인터넷 애플릿 프로그램의 주요 언어가 됨. <br><br>
>
> [현재] <br>
  > - 빅데이터를 효과적으로 처리할 필요↑. <br>
  > → 지금까지의 자바로는 병렬 프로세싱을 대응 X. → 자바 8 등장.

<br><br>


### 자바의 성공 이유 <br>
  1. 캡슐화 → C에 비해 소프트웨어 엔지니어링적인 문제가 적음.
  2. 객체지향의 정신적인 모델 → 윈도우 95 및 그 이후의 WIMP 프로그래밍 모델에 쉽게 대응 가능. <br>
     ** 객체지향 개발 5대 원칙 : SOLID <br><br><br><br>


### 자바8 설계의 세 가지 프로그래밍 개념 <br>
  *변화 방향성 : 고전적인 객체지향 → 함수형 프로그래밍* <br><br>

#### 1. 스트림 처리
> - 작업을 추상화를 통해 일련의 스트림으로 만들어 처리할 수 있다는 장점. <br>
> - 스트림 파이프라인을 통해 입력 부분을 여러 CPU 코어에 쉽게 할당할 수 있다는 장점.<br>
>  => 스레드를 사용하지 않고도 병렬성을 얻을 수 O. <br><br>
      
#### 2. 동작 파라미터화로 코드 일부를 API로 전달
> - 바뀐 점 : 메서드를 다른 메서드의 인수로 넘겨주는 기능 제공. <br>
> *동작 파라미터화 : 아직 어떻게 실행할 것인지 결정하지 않은 코드 블럭을 의미*<br><br>
  
  #### 3. 병렬성과 공유 가변 데이터
> - 문제점 : 안전하게 실행하기 위해선 가변데이터에 접근 X. 하지만 공유된 변수나 객체가 있으면 병렬성에 문제 발생.<br>
> - 기존 방식 : synchronized를 이용하여 공유된 가변 데이터를 보호하는 규칙 생성. <br>
> → 하지만, 다중 프로세싱 코어의 경우 위의 방법으로는 순차적 실행이 되기 때문에 병렬 X. <br>
>   1. 라이브러리에서 분할 처리. (큰 스트림을 병렬로 처리할 수 있도록 작은 스트림으로 분할) <br>
>   2. filter 같은 라이브러리 메서드로 전달된 메서드가 상호작용을 하지 않는다면 가변 공유 객체를 통해 공짜로 병렬성 O. <br><br>
*synchronized : 여러개의 스레드가 한개의 자원을 사용하고자 할 때, 현재 데이터를 사용하고 있는 해당 스레드를 제외하고 나머지 스레드들은 데이터에 접근 할 수 없도록 막는 개념.* <br>

---
## 자바 8에 추가된 새로운 개념
### 1. 자바 함수 <br>
- 배경 : 메서드, 클래스 등 이급 시민을 일급 시민으로 바꾸어 프로그래밍을 수월하게 만들기 위해. <br><br>
  **1급 시민의 조건 3가지**
   1. 변수나 데이타에 할당 할 수 있어야 한다.
   2. 객체의 인자로 넘길 수 있어야 한다.
   3. 객체의 리턴값으로 리턴 할수 있어야 한다. 

<br><br>
**1) 메서드 참조** <br>
	- ToDo : 메서드를 값으로. <br>
	- 기존에는 직접 찾아들어가 찾았어야했지만, '클래스명::메서드명'을 사용하여 바로 참조 가능하게 됨.<br>
```
Integer::compareTo
```
<br><br>
**2) 람다: 익명함수** <br>
> - ToDo : 함수를 값으로. <br>
> - 기존에는 조건문만 다른 코드를 복붙하여 수정이 어려웠지만, 지금은 코드를 인수로 넘겨줄 수 있게 됨.<br>
> *참고로, 메서드 참조한 값을 함수 파라미터로 줄 땐, 프리디케이트 사용* <br>
```
static List<Apple> filterApples(List<Apple> inventory, Predicate<Apple> p) { ... }
	
filterApples(inventory, Apple::isGreenApple);
```
<br><br>
**3) 메서드 전달에서 람다로** <br>
> - 배경 : 한두 번 사용할 매서드를 매번 정의하지 않기 위해. <br>
	```
	public static boolean isGreenApple(Apple apple){
	  return GREEN.equals(apple.getColor());
	}
	                         ↓   
	filerApple(inventory, (Apple a) -> GREEN.equals(a.getColor()));
	
	```
	```
	public static boolean isHeavyApple(Apple apple){
	  return apple.getWeight() > 150;
	}
	                         ↓   
	filerApple(inventory, (Apple a) -> a.getWeight() > 150);
	```
	- filter method 사용.
	```
	filter(inventory, (Apple a) -> a.getWeight() > 150);
	```
<br><br><br>
### 2. 스트림
**1. 스트림 API(java.util.stream)** <br>
- 배경: 배열이나 컬렉션을 사용할 때 여기에 저장된 데이터에 접근하기 위해서 반복문 사용. → 가독성 저하. 코드 길이↑ <br>
- 이를 통해, <br>
  컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제, <br>
  멀티코어 활용 어려움을 해결. <br><br>

### 주요 특징
- 원본 데이터를 변경X. <br>
- '내부 반복(internal iteration)'을 통해 라이브러리 내부에서 모든 데이터가 처리됨. <br>
- 재사용이 가능한 컬렉션과는 달리 단 한 번만 사용할 수 있다. <br>
- parallelStream() 메서드를 통한 손쉬운 병렬 처리를 지원. <br>

### 주요 기능
필터링(컬렉션 -> 스트림 -> 병렬처리 -> 리스트로 복원), 추출, 그룹화 등

*포킹 단계 : 두 CPU를 가진 환경에서 리스트를 필터링할 때, 한 CPU는 리스트의 앞부분을 처리하고 다른CPU는 리스트의 뒷부분을 처리하도록 요청.* <br><br>
**차이점** <br>
컬렉션은 어떻게 데이터를 저장하고 접근할 지. <br>
스트림은 데이터에 어떤 계산을 할 것인지. <br><br>


### 3. 디폴트 메서드와 자바 모듈
- 문제점 : 인터페이스에 추상메서드를 추가하게 되면 모든 구현체에 구현을 해야함. <br>
- 사용 방법은, <br>
> 메서드 앞에 default 예약어를 붙인다. <br>
> 구현부 {} 가 있어야 한다. <br>
```
public interface Interface {
   // 추상 메서드 
    void abstractMethodA();
    void abstractMethodB();
    void abstractMethodC();

    // default 메서드
    default int defaultMethodA(){
    	...
    }
}
```
---
### 정리
#### 함수형 프로그래밍의 핵심적인 아이디어
1. 메서드와 람다를 일급값으로 사용.
2. 가변 공유 상태가 없는 병렬 실행을 이용해서 효율적이고 안전하게 함수나 메서드 호출 가능.
