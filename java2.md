# CHAPTER 2. 동작 파라미터화 코드 전달하기

동작 파라미터란? 아직은 어떻게 실행할 것인지 결정하지 않은 코드 블록.
나중에 프로그램에서 호출. 즉 실행은 나중으로 미뤄진다.
-> 변화하는 요구사항에 쉽게 적응하는 유용한 패턴임.

동작 파라미터화 패턴 : 동작을 캡슐화  ---메서드로 전달--->  메서드의 동작을 파라미터화.

강점 : 동작을 분리할 수 있다는 점. 


### 변화하는 요구사항에 대응하기
1. 녹색 사과 필터링 -> 문제점 : 다양한 색의 필터링 불가

2. 색을 파라미터화 -> 문제점 : 코드 중복. DRY(Don't repeat yourself)르르 어기는 것.

3. 모든 속성을 파라미터화 -> 문제점 : 유연하게 대응 불가.

** *프레디케이트 : 참 또는 거짓을 반환하는 함수.

4. 추상적 조건, 즉 인터페이스 파라미터화 -> 유연성 확보 !
: 하지만, 인터페이스를 구현하는 여러 클래스를 정의 -> 인스턴스화
=> 로직과 관련 없는 코드가 많이 추가.

---
###### 여기서부턴, 복잡한 과정 간소화

이를 해결하고자 클래스 선언과 동시에 인스턴스화를 할 수 있는 "익명 클래스"라는 기법 제공.

5. 익명 클래스 사용
: 이름이 없는 클래스. 클래스 선언과 인스턴스화를 동시에 할 수 있음. 즉석으로 필요한 구현 만들어서 사용 가능.

-> 하지만 이것조차 많은 공간 차지.

6. 람다 표현식 사용
-> 복잡성 문제 해결 !

7. 리스트 형식으로 추상화



### 실전 예제 (자바 API의 많은 메서드를 다양한 동작으로 파라미터화)
1. Comparator로 정렬하기
   : 변화하는 요구사항에 대응할 수 있는 '다양한 정렬 동작'
```
public interface Comparator<T> {
  int compare(T o1, T o2);
}

inventory.sort(new Comparator<Apple>() {
  public int compare(Apple a1, Apple a2){
    return a1.getWeight().compareTo(a2.getWeight());
});
```
OR 
```
inventory.sort((Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()));
``` 
   
2. Runnable로 코드 블록 실행하기
```


```
   
4. Callable을 결과로 변환하기
5. GUI 이벤트 처리하기








